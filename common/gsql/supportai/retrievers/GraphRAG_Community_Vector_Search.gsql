/*
 * Copyright (c) 2025 TigerGraph, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

CREATE OR REPLACE DISTRIBUTED QUERY GraphRAG_Community_Vector_Search(LIST<FLOAT> query_vector, INT community_level=2, INT top_k = 3, BOOL with_chunk = true, BOOL with_doc = false, BOOL verbose = false) { 
  MapAccum<Vertex, SetAccum<String>> @@final_retrieval;
  MapAccum<STRING, SetAccum<Vertex>> @@verbose_info;
  SetAccum<STRING> @context;
  SetAccum<Vertex> @children;
  SetAccum<Vertex> @@start_set;
  
  filtered_comms = SELECT c FROM Community:c WHERE c.iteration == community_level and length(c.description) > 0;
  start_comms = vectorSearch({Community.embedding}, query_vector, top_k, {candidate_set: filtered_comms});

  start_comms = SELECT c FROM start_comms:c WHERE c.type == "Community"
      POST-ACCUM @@start_set += c;

  @@verbose_info += ("start_set" -> @@start_set);
  selected_comms = start_comms;

  IF with_chunk or with_doc THEN
      FOREACH i IN RANGE[community_level, 2].STEP(-1) DO
          selected_comms = SELECT c FROM selected_comms:s -(<HAS_PARENT)- Community:c
              WHERE s.iteration == i
              ACCUM s.@children += c
              POST-ACCUM @@verbose_info += ("community_level_"+to_string(i-1) -> s.@children);
      END;
      start_chunks = vectorSearch({DocumentChunk.embedding}, query_vector, top_k);
      extra_selected_comms = SELECT m FROM start_chunks:dc -(CONTAINS_ENTITY>)- Entity:v -(RESOLVES_TO>)- ResolvedEntity:r -(IN_COMMUNITY>)- Community:m;
      selected_comms = selected_comms UNION extra_selected_comms;

      IF with_doc THEN
          related_chunks = SELECT c FROM Content:c -(<HAS_CONTENT)- Document:d -(HAS_CHILD>)- DocumentChunk:dc -(CONTAINS_ENTITY>)- Entity:v -(RESOLVES_TO>)- ResolvedEntity:r -(IN_COMMUNITY>)- selected_comms:m
              ACCUM m.@context += c.text, m.@children += d
              POST-ACCUM @@verbose_info += ("related_chunks" -> m.@children);
      ELSE
          related_chunks = SELECT c FROM Content:c -(<HAS_CONTENT)- DocumentChunk:d -(CONTAINS_ENTITY>)- Entity:v -(RESOLVES_TO>)- ResolvedEntity:r -(IN_COMMUNITY>)- selected_comms:m
              ACCUM m.@context += c.text, m.@children += d
              POST-ACCUM @@verbose_info += ("related_chunks" -> m.@children);
      END;
  END;

  selected_comms = SELECT c FROM selected_comms:c -(HAS_PARENT>*0..)- start_comms:s WHERE s.type == c.type and c.type == "Community"
      ACCUM s.@context += s.description, s.@context += c.@context
      POST-ACCUM(s) @@final_retrieval += (s -> s.@context);

  PRINT @@final_retrieval as final_retrieval;

  IF verbose THEN
      PRINT @@verbose_info as verbose;
  END;
}
